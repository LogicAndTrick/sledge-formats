using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using Microsoft.VisualStudio.TestTools.UnitTesting;
using Sledge.Formats.Map.Formats;
using Sledge.Formats.Map.Objects;
using Sledge.Formats.Precision;

namespace Sledge.Formats.Map.Tests.Units;

[TestClass]
public class TestIntersectingPolyhedron
{
    private const string CubeRmf = "zcwMQFJNRgAAAAAKQ01hcFdvcmxkAAAAAAD///8BAAAACkNNYXBTb2xpZAAAAAAAAIH/AAAAAAYAAABmaWZ0aWVzX3dhbGwxMmQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAgD8AAAAAAAAAAAAAAAAAAAAAAAAAAAAAgL8AAAAAAAAAAAAAgD8AAIA/AAAAAAAAAAAAAAAAAAAAAAQAAAAAABBDAAAAAAAAgEEAABBDAAAAAAAAAIAAAABDAAAAAAAAAAAAAABDAAAAAAAAgEEAABBDAAAAAAAAgEEAABBDAAAAAAAAAIAAAABDAAAAAAAAAABmaWZ0aWVzX3dhbGwxMmQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAgL8AAAAAAAAAAAAAAAAAAAAAAAAAAAAAgL8AAAAAAAAAAAAAgD8AAIA/AAAAAAAAAAAAAAAAAAAAAAQAAAAAAABDAACAQQAAgEEAAABDAACAQQAAAAAAABBDAACAQQAAAAAAABBDAACAQQAAgEEAAABDAACAQQAAgEEAAABDAACAQQAAAAAAABBDAACAQQAAAABmaWZ0aWVzX3dhbGwxMmQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIC/AAAAAAAAAAAAAAAAAAAAAAAAgL8AAAAAAAAAAAAAgD8AAIA/AAAAAAAAAAAAAAAAAAAAAAQAAAAAAABDAAAAAAAAgEEAAABDAAAAAAAAAAAAAABDAACAQQAAAIAAAABDAACAQQAAgEEAAABDAAAAAAAAgEEAAABDAAAAAAAAAAAAAABDAACAQQAAAIBmaWZ0aWVzX3dhbGwxMmQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIA/AAAAAAAAAAAAAAAAAAAAAAAAgL8AAAAAAAAAAAAAgD8AAIA/AAAAAAAAAAAAAAAAAAAAAAQAAAAAABBDAACAQQAAgEEAABBDAACAQQAAAAAAABBDAAAAAAAAAIAAABBDAAAAAAAAgEEAABBDAACAQQAAgEEAABBDAACAQQAAAAAAABBDAAAAAAAAAIBmaWZ0aWVzX3dhbGwxMmQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAgD8AAAAAAAAAAAAAAAAAAAAAAACAvwAAAAAAAAAAAAAAAAAAgD8AAIA/AAAAAAAAAAAAAAAAAAAAAAQAAAAAAABDAACAQQAAgEEAABBDAACAQQAAgEEAABBDAAAAAAAAgEEAAABDAAAAAAAAgEEAAABDAACAQQAAgEEAABBDAACAQQAAgEEAABBDAAAAAAAAgEFmaWZ0aWVzX3dhbGwxMmQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAgL8AAAAAAAAAAAAAAAAAAAAAAACAvwAAAAAAAAAAAAAAAAAAgD8AAIA/AAAAAAAAAAAAAAAAAAAAAAQAAAAAABBDAACAQQAAAAAAAABDAACAQQAAAAAAAABDAAAAAAAAAAAAABBDAAAAAAAAAAAAABBDAACAQQAAAAAAAABDAACAQQAAAAAAAABDAAAAAAAAAAALd29ybGRzcGF3bgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA";
    
    [TestMethod]
    public void TestRmfToMap()
    {
        var rmf = new WorldcraftRmfFormat();
        using var stream = new MemoryStream(Convert.FromBase64String(CubeRmf));
        var map = rmf.Read(stream);
        var cube = (Solid) map.Worldspawn.Children[0];
        var poly = new Polyhedron(cube.Faces.Select(x => new Plane(x.Plane.Normal.ToPrecisionVector3(), x.Plane.D)));

        Assert.AreEqual(cube.Faces.Count, poly.Polygons.Count);
        foreach (var origFace in cube.Faces)
        {
            var newFace = poly.Polygons.Single(x => x.Plane.EquivalentTo(new Plane(origFace.Plane.Normal.ToPrecisionVector3(), origFace.Plane.D)));
            var firstVertexIndex = newFace.Vertices.ToList().FindIndex(x => x.EquivalentTo(origFace.Vertices[0].ToPrecisionVector3()));
            for (var origIndex = 0; origIndex < origFace.Vertices.Count; origIndex++)
            {
                var newIndex = (firstVertexIndex + origIndex) % origFace.Vertices.Count;
                var ov = origFace.Vertices[origIndex].ToPrecisionVector3();
                var nv = newFace.Vertices[newIndex];
                Assert.IsTrue(ov.EquivalentTo(nv));
            }
        }
    }
}